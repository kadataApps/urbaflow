# Inspired from (c) Vincent Chery - MonitorEnv

import logging
import sys
from typing import Sequence

import geoalchemy2
import sqlalchemy
from sqlalchemy import MetaData, Table, func, select
from sqlalchemy.exc import InvalidRequestError

# ***************************** Database operations utils *****************************


def get_table(
    table_name: str,
    schema: str,
    conn: sqlalchemy.engine.Connectable,
    logger: logging.Logger,
) -> sqlalchemy.Table:
    """Performs reflection to get a sqlalchemy Table object with metadata reflecting
    the table found in the databse. Returns resulting Table object.

    If the table is not found in the database, raises an error.
    """

    meta = MetaData(schema=schema)
    try:
        geoalchemy2
        assert "geoalchemy2" in sys.modules
    except (AssertionError, NameError):
        logger.error(
            "geoalchemy2 must be imported for geometry support in table reflection."
        )
        raise

    try:
        logger.info(f"Searching for table {schema}.{table_name}...")
        meta.reflect(bind=conn, only=[table_name], views=True)
        table = Table(table_name, meta, must_exist=True)
        logger.info(f"Table {schema}.{table_name} found.")
    except InvalidRequestError:
        logger.error(
            f"Table {schema}.{table_name} must exist. Make appropriate migrations "
            + "and try again."
        )
        raise

    return table


def delete(
    table: sqlalchemy.Table,
    connection: sqlalchemy.engine.base.Connection,
    logger: logging.Logger,
):
    """Deletes all rows from a table.
    Useful to wipe a table before re-inserting fresh data in ETL jobs."""
    count_statement = select(func.count()).select_from(table)
    n = connection.execute(count_statement).fetchall()[0][0]
    if logger:
        logger.info(f"Found existing table {table.name} with {n} rows.")
        logger.info(f"Deleting table {table.name}...")
    connection.execute(table.delete())
    count_statement = select(func.count()).select_from(table)
    n = connection.execute(count_statement).fetchall()[0][0]
    if logger:
        logger.info(f"Rows after deletion: {n}.")


def delete_rows(
    table: sqlalchemy.Table,
    id_column: str,
    ids_to_delete: Sequence,
    connection: sqlalchemy.engine.base.Connection,
    logger: logging.Logger,
):
    """Deletes all rows of a table whose id is in ``ids_to_delete``.

    Args:
        table (sqlalchemy.Table): table to remove rows from
        id_column (str): name of the column in the table that contains ids to delete
        ids (Sequence): list-like sequence of ids to look for in the table and delete
        connection (sqlalchemy.engine.base.Connection): database connection
        logger (logging.Logger): logger

    """
    count_statement = select(func.count()).select_from(table)
    n = connection.execute(count_statement).fetchall()[0][0]
    if logger:
        logger.info(f"Found existing table {table.name} with {n} rows.")
        logger.info(f"Deleting some rows from table {table.name}...")

    # to avoid certain type errors generated by psycopg2
    ids_to_delete = list(map(str, ids_to_delete))

    connection.execute(table.delete().where(table.c[id_column].in_(ids_to_delete)))

    count_statement = select(func.count()).select_from(table)
    n = connection.execute(count_statement).fetchall()[0][0]
    if logger:
        logger.info(f"Rows after deletion: {n}.")
